# \#01 신뢰성, 확장성 그리고 유지보수성

데이터 중심 애플리케이션 구축\([Designing Data-Intensive Application](https://www.amazon.co.uk/Designing-Data-Intensive-Applications-Reliable-Maintainable/dp/1449373321/ref=sr_1_1?crid=19FEOM6Z8O3TT&dchild=1&keywords=designing+data-intensive+applications&qid=1589505997&sprefix=desinging+%2Caps%2C-1&sr=8-1)\) 책을 읽고 정리하였습니다.

### 어플리케이션에서 당연히 필요한 것들

* 데이터베이스
* 캐시
* 검색 엔진
* 스트리밍 프로세싱
* 배치 프로세싱

## 1. 신뢰성

* 응용 프로그램은 사용자가 예상한 기능을 수행합니다.
* 사용자가 실수를 하거나 소프트웨어를 예기치 않은 방식으로 사용하는 것을 수용할 수 있습니다.
* 예상로드 및 데이터 볼륨에서 요구된 사용 환경에 충분한 성능을 제공합니다.
* 시스템은 무단 액세스 및 남용을 방지합니다.
* 즉, 어떠한 상황에도 잘 수행된다는 것

#### **fault와 failure 차이**

* **fault** - 일반적으로 사양에서 벗어난 시스템의 한 구성 요소
* **failure** - 시스템이 전체적으로 사용자에게 필요한 서비스를 제공하지 못하는 경우  
* 결론, ****fault를 줄여가면 failure가 발생하지 않게 만들어 가는 것. \(eg. 넷플릭스 카오스 몽키\)

### 1.1 하드웨어 fault 막기 

하드웨어는 평균 고장시간\([MTTF](https://m.blog.naver.com/pxckr/220838433353)\) 10~50년 정도 걸린다. 

#### **예방법**

* RAID
* 듀얼 파워서플라이
* 배터리와 디젤 전기생산기가 있는 데이터센터 구축
* 전원이 켠상태로 교체 가능\([hot-swappable\)](https://m.blog.naver.com/1977cc/110153669148)한 CPU  

**\*a rolling upgrade** -&gt; 전체 시스템 죽이지 않고 노드 하나씩 패치하는 방법.

###  1.2 소프트웨어 에러

하드웨어 하나가 고장났다고 전부가 고장나는 경우는 매우 드물다.\(자연재해 같은것 말고\) = weak correlations이에 반해, 소프트웨어는 하나 고장시 도미노 처럼 무너지는 경우가 생길 수 있다.\(예시 - leap second / 무한회귀하는 프로세스\(runaway process\) - 자원 고갈\)  
예방법

* 잘 설계된 추상화, API 및 관리 인터페이스
* 샌드박스 환경 제공 -&gt; 실제 사용자에게 영향을주지 않고 실제 데이터를 사용하여 안전하게 실험할 수 있는 환경을 제공
* 테스트 -&gt; 단위 테스트에서 전체 시스템 통합 테스트에 이르기까지 모든 수준에서 철저히 테스트. 자동화 테스트 사용\( [corner cases](https://bakyeono.net/post/2015-05-02-edge-case-corner-case.html) 찾기 좋음 \)
* 빠르고 쉬운 복구 -&gt;  roll out new code gradually
* 모니터링-&gt; 성능 지표\(performance metrics\) 및 오류율\(error rate\)
* 준수한 관리 관행 및 교육

  
신뢰성이 얼마나 중요한가?부모님이 자식 사진을 서버에 저장했는데 신뢰성이 없다면....



## 2. 확장성

### 2.1 부하 확인

 소프트웨어의 성능 저하는 대부분 increased load.   
즉, Scalability = 증가한 부하를 잘 대응할 수 있는 가능성이고, 측정이 가능해야 확장 가능성에 대해 대화가능하다.

**부하 매개변수load parameters\) 숫자들로 설명가능.** **예를 들어,** 

* 초당 웹서버 들어오는 요청수
* 읽기에 대한 쓰기에 대한 비율
* 채팅룸에서 유저들의 동시 접속수
* 캐시의 hit rate

#### 트위터 사례분석\(트위터의 두가지 기능 - Post tweet / Home timeline\) 

과정: 사용자가 홈 타임 라인을 요청 -&gt; 팔로우하는 모든 사람을 찾아 각 사용자에 대한 모든 트윗을 검색 -&gt; 시간별로 정렬

1. Post tweet - 팔로워들에게 새로운 메시지를 보낸다.\(초당 4600개에서 최대 12000개 요청\)   
2. Home timeline - 팔로우하는 사람들의 트윗을 확인한다. \(초당 300,000 요청\)

```sql
SELECT tweets.*, users.* FROM tweets
 JOIN users ON tweets.sender_id = users.id
 JOIN follows ON follows.followee_id = users.id
 WHERE follows.follower_id = current_user
```

![\[&#xADF8;&#xB9BC; 1\] &#xD2B8;&#xC704;&#xD130;&#xC758; &#xD14C;&#xC774;&#xBE14; &#xAD6C;&#xC870;](../../.gitbook/assets/image%20%281%29.png)

* **`tweets`** 트윗 내용 테이블
* **`users`** 유저 테이블
* **`follows`** 유저가 팔로우하는 팔로이들 목록 테이블

> 내가 쿼리를 짯다면... 인라인로 유저테이블과 팔로우테이블을 조인하여 현재 유저가 팔로우하는 follow\_id를 받는다. 이 follow\_id로 트윗테이블을 찾아가면서 트윗을 가져와 홈타임라인에 표시한다.



### 2.2 성능 확인

부하를 확인할 수 있게 되었으면, 부하가 높아졌을 때 성능을 측정한다.

1. CPU, 메모리 그리고 네트워크 대역폭과 같은 자원증축 없이, 부하 파라미터를 증가시키면 성능이 어떻게 변화할까?
2. 부하증가시 성능변화없이 유지하고 싶다면, 얼마나 많은 자원을 투입해야할까?

**배치처리 시스템** -&gt; **처리량**\(throughput\)이 중요   
**온라인 시스템** -&gt; 서비스의 **응답시간**이 중요

> **지연시간\(Latency\)와 응답시간\(Response time\) 차이**
>
> * Latency - 요청이 처리되기 위해 기다리는 시간
> * Response time - 요청을 처리하는데 드는 실제 서비스시간\(네트워크지연, 큐잉지연 포함\).

![\[&#xADF8;&#xB9BC; 2\] 100&#xAC1C;&#xC758; &#xC11C;&#xBE44;&#xC2A4; &#xC694;&#xCCAD;](../../.gitbook/assets/image%20%282%29.png)

**동일한 서비스 실행 시 답시간이 다른 이유들**

* 백그라운드 프로세스로의 [컨택스트 스위치](https://jeong-pro.tistory.com/93)
* 네트워크 패킷 손실과 TCP 재전송
* 가비지 컬렉션 멈
* 디스크로부터 강제 읽게하는 페이지 오류
* 서버랙\(장비틀\)의 기계적인 진동
* 기타 등

이러한 이유들로, 성능측정시에는 백분위수\(percentiles\)을 이용한다. \(응답시간 리스트를 시간 순서대로 나열해 중간지점\(median\)을 구한다.\) 이로써 유저가 평균적으로 얼마나 기다려야 하는지를 알 수 있다. 아마존에서 응답시간이 0.1초 증가시 판매가 1% 떨어지는 것을 확인하였고, 다른 조사기관에서 1초가 느려질시 소비자 만족지수가 16% 떨어짐을 확인하였다. 따라서, 응답시간을 잘 체크 해야한다. \(SLA에도 이용\)





#### 2.3 Approaches for Coping with Load





