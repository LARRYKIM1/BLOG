---
description: 'Joshua Bloch 저 이복연 역 「Effective Java 3rd Edition, 2018」를 읽고 정리하였습니다.'
---

# \#\[2주차\] 아이템7-14

## 아이템 7: finalized cleaner 사용을 피하라.

* 자바는 두 가지 객체 소멸자를 제공한다.
* finalizer는 기본적으로 쓰지 말아야 한다. 자바 9에서 deprecated API로 지정되고 cleaner를 그 대안으로 소개 했다.
* cleaner는 finalizer보다는 덜 위험하지만 여전히 예측할 수 없고 느리고 일반적으로 불 필요하다.
* C++의 destructor와는 다른 개념이다. destructor는 특정 객체와 관련된 자원을 회수하는 보편적인 방법이다. \( 비 메모리 자원을 회수하는 용도 \)
* 자바에서는 **접근할 수 없게 된 객체**를 회수하는 역할을 가비지 컬렉터가 담당한다.
* 자바에서는 try-withresources와 try-finally를 사용해 해결한다.
* finalizer와 cleaner는 즉시 수행된다는 보장이 없다. 따라서 제때 실행되어야 하는 작업에 절대 사용면 안된다.
* finalizer나 cleaner를 얼마나 신속히 수행할지는 전적으로 가비지 컬렉터 알고리즘에 달렸으며, 이는 가비지 컬렉터 구현마다 천차만별이다. 테스트한 JVM에서는 완벽하게 동작하던 프로그램이 가장 중요한 고객의 시스템에서는 엄청난 재앙을 일으킬지도 모른다.
* 저자 친구 GUI프로그램이 OutOfMemory 에러가 낫고, 원인은 객체 수천개가 finalizer에서 기다리고 있었는데... finalizer 스레드가 다른 애플리케이션 스레드보다 우선 순위가 낮아서 실행될 기회를 제대로 얻지 못한 것이다.
* 사례를 들어 데이터베이스 같은 공유 자원의 영구 락 해제를 finalizer나 cleaner에 맡겨 놓으면 분산 시스템 전체가 서서 히 멈출 것이다.
* `System.gc`나 `System.runFinalization` 메서드는 finalizer와 cleaner가 실행될 가능성을 높여줄 수는 있으나 보장해주진 않는다. 문제를 보장하기 위해 System.runFinalizersOnExit, Runtime.runFinalizersOnExit 메서드가 있어왔으나 심각한 결함이 있다.
* finalizer를 사용한 클래스는 final izer 공격 =에 노출되어 심각한 보안 문제를 일으킬 수도 있다.
* 공격원리 -&gt; 생성자나 직렬화 과정\(ReadObject와 readResolve 메서드, 12장\)에서 예외가 발생하면, 이 생성되다 만 객체에서 악의적인 하위 클래스의 finalizer가 수행될 수 있게 된다.
* AutoClosable은 12ns가 걸린 반면 finalizer를 사용하면 550ns 걸렸다. 안정망을 설치할때는 66ns가 걸렸다.
* 안전망: finalize\(\) 안에서 close\(\)를 호출해준다. FileInputStream 참고.
* 객체 생성을 막으려면 생성자에서 예외를 던지는 것만으로 충분하지만 finalizer가 있다면 그렇지도 않다.

```java
public class Room implements AutoCloseable {
    private static final Cleaner cleaner = Cleaner.create(); // 안정망으로 사용
​
    private final State state;
    private final Cleaner.Cleanable cleanable;
​
    Room(int numJunkPile) {
        System.out.println("쓰레기 수 = " + numJunkPile);
        state = new State(numJunkPile);
        cleanable = cleaner.register(this, state); // 등록할 때 State의 run 메서드 실행
    }
​
    private static class State implements Runnable { // 정적 중첩 클래스 = 바깥 객체의 참조 가질 수 x
        int numJunkPile;
​
        State(int numJunkPile) {
            this.numJunkPile = numJunkPile;
        }
​
        @Override
        public void run() {
            System.out.println("방 청소중");
            numJunkPile = 0;
        }
    }
​
    @Override
    public void close() throws Exception {
        cleanable.clean(); 
    }
​
    public static void main(String[] args) throws Exception {
//        //초보자
//        new Room(99);
//        System.out.println("쉬는 중");
//        System.gc(); // "방 청소중"이 나올 수도 안 나올 수도...
​
        // 고수
        try (Room myRoom = new Room(7)) { // 자동 청소 필요 없어진다.
            System.out.println("Goodbye");
        }
    }
​
}
```

더 현실적으로 만들려면 numJunkPile 필드는 네이티브 피어를 가리키는 포인터를 담은 final long 변수여야 한다.

 run 메서드는 cleanable에 의해 딱 한 번만 호출된다. \(등록시 호출\)

State 인스턴스는 절대로 Room 인스턴스를 참조해서는 안 된다. 순환참조가 생겨 가비지 컬렉터가 Room 인스턴스를 회수 해갈 기회가 오지 않는다.

Room의 cleaner는 안전망으로만 쓰였다. 클라이언트가 모든 Room 생성을 **try-with-resources 블록**으로 감왔다면 자동 청소는 전혀 필요하지 않다.

## 아이템 8: finalized cleaner 사용을 피하라.

추후 작성



## 아이템 9: try-finally보다는 try-with-resources를 사용하라

자바 라이브러리에는 close 메서드를 호출해 직접 닫아줘야 하는 자원이 많다. Inputstream, Outputstream, java.sql.Connection 등좋은 예다. 자원 닫기는 클라이언트가 놓치기 쉬워서 예측할 수 없는 성능 문제로 이어지기도 한다. 이런 자원 중 상당수가 안전망으로 finalizer를 활용하고는 있지만 finalized 그리 믿을만하지 못하다\(아이템 8\).

```java
​
public class Item09 {
​
    // 1 try-finally 사용
    static String firstLineOfFile01(String path) throws IOException {
        BufferedReader br = new BufferedReader(new FileReader(path));
        try {
            return br.readLine(); 
        }finally {
            br.close(); // readLine에서 예외 발생후, 여기서 예외 발생시 readLine 예외를 볼 수 없는 문제..
        }
    }
​
    // 2 try-with-resources 사용 (자바 7)
    static String firstLineOfFile02(String path) throws IOException {
        try(BufferedReader br = new BufferedReader(new FileReader(path));){
            // close에서 발생한 예외는 숨겨지고 readLine에서 발생한 예외가 기록된다.
            return br.readLine();
        }
    }
​
    public static void main(String[] args) throws IOException {
        String path = "src/com/larrykim/common/data.txt";
//        System.out.println(Item09.firstLineOfFile01(path)); 
        System.out.println(Item09.firstLineOfFile02(path));
    }
​
}
```

만약 사용하는 자원이 두개였다면.. try-finally는 아래 같이 복잡해진다.

```java
private static final int BUFFER_SIZE = 8 * 1024;
​
// 1 try-finally 
static void copy(String src, String dst) throws IOException {
    InputStream in = new FileInputStream(src);
    try {
        OutputStream out = new FileOutputStream(dst);
        try {
            byte[] buf = new byte[BUFFER_SIZE];
            int n;
            while ((n = in.read(buf)) >= 0)
                out.write(buf, 0, n);
        } finally {
            out.close(); // 명시적으로 close
        }
    } finally {
        in.close(); // 명시적으로 close
    }
}
------------------------------------------------------------
// 2 try-with-resources
static void copy(String src, String dst) throws IOException {
    try (InputStream in = new FileInputStream(src);
         OutputStream out = new FileOutputStream(dst)) {
        byte[] buf = new byte[BUFFER_SIZE];
        int n;
        while ((n = in.read(buf)) >= 0)
            out.write(buf, 0, n);
 }
​
```

그리고 try-finally 문을 제대로 사용한 앞의 두 예제 조차 미묘한 결점이 있다. 예외는 try 블록과 finally 블록 모두에서 발생할 수 있는데, 예컨대 기기에 물리적인 문제가 생긴다면 firstLineOfFile01 메서드 안의 readLine 메서드가 예외를 던지고 같은 이유로 close 메서드도 실패할 것이다. 이런 상황이라면 두 번째 예외가 첫 번째 예외를 완전히 집어삼켜 버린다. 그러면 스택 추적 내역에 첫 번째 예외에 관한 정보는 남지 않게 되어 실제 시스템에서의 디버깅을 몹시 어렵게 한다\(일반적으로 문제를 진단하려면 처음 발생한 예외를 보고 싶을 것이다\).

#### 대비되는 try-with-resources 장점

close에서 발생한 예외는 숨겨지고 readLine에서 발생한 예외가 기록된다. 이렇게 숨겨진 예외들도 그냥 버려지지는 않고, 스택 추적 내역에 "숨겨졌다"는 \(suppressed\) 꼬리표를 달고 출력된다. 또한, 자바 7에서 Throwable에 추가 된 getSuppressed\(\)를 이용하면 프로그램 코드에서 가져올 수도 있다.

#### 총코드

```java
​
public class Item09 {
    private static final int BUFFER_SIZE = 8 * 1024;
​
    static String firstLineOfFile_tryFinally(String path) throws IOException {
        BufferedReader br = new BufferedReader(new FileReader(path));
        try {
            return br.readLine();
        } finally {
            br.close();
        }
    }
​
    static String firstLineOfFile0_tryWithResources(String path) throws IOException {
        try (BufferedReader br = new BufferedReader(new FileReader(path));) {
            return br.readLine();
        }
    }
​
    static void copy_tryWithResources(String src, String dst) throws IOException {
        try (InputStream in = new FileInputStream(src);
             OutputStream out = new FileOutputStream(dst)) {
            byte[] buf = new byte[BUFFER_SIZE];
            int n;
            while ((n = in.read(buf)) >= 0) {
                System.out.println("쓰기할 바이트 수 = " + n);
                out.write(buf, 0, n); // 데이터, 시작점, 쓰기할 바이트수
            }
        }
    }
​
    public static void main(String[] args) throws IOException {
//        String path = "src/com/larrykim/common/data.txt";
////        System.out.println(Item09.firstLineOfFile_tryFinally(path));
//        System.out.println(Item09.firstLineOfFile0_tryWithResources(path));
​
        String src = "src/com/larrykim/common/data.txt";
        String dst = "src/com/larrykim/common/data_dst.txt";
        copy_tryWithResources(src, dst);
    }
}
```

요약, 꼭 회수해야 하는 자원을 다룰 때는 try-finall 말고, try-with-resources를 사용하자.

## 3장 \(10-14\) 모든 객체의 공통 메서드 

Object는 객체를 만들 수 있는 **구체 클래스**지만 기본적으로는 **상속해서 사용하도록 설계**되었다. Object에서 **final이 아닌 메서드**\(equals, hashCode, toString, clone, finalize\)는 모두 **재정의\(overriding\)를 염두**에 두고 설계된 것이라 재정의 시 지켜야 하는 **일반 규약이 \(general contracts\) 명확히 정의되어 있다.** 그래서 **Object를 상속하는 클래스,** **즉** **모든 클래스**는 이 메서드들을 일반 규약에 맞게 재정의해야 한다. 메서드를 잘못 구현하면 대상 클래스가 이 규약을 준수한다고 가정하는 클래스\(**HashMap과 HashSet 등**\)를 오동작하게 만들 수 있다.

이번 장에서는 final이 아닌 Object 메서드들을 언제 어떻게 재정의해야 하는지를 다룬다.

## 아이템 10: equals는 일반 규약을 지켜 재정의하라.





