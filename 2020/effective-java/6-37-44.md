---
description: 'Joshua Bloch 저  이복연 역  「Effective Java 3rd Edition, 2018」를 읽고 정리하였습니다.'
---

# \[6주차\] 37-44

## 39 명명패턴보다 애너테이션 사용 - 발

#### 명명방식 문제점

1 tsetSafetyOverride -&gt; 오타 때문에 JUnit3은 무시 -&gt; 실패, 통과 여부 모름.   
2 메서드가 아닌 클래스 TestSafetyMechanisms은 JUnit에서 관심이 없다.   
3 프로그램 요소를 매개변수로 전달할 마땅한 방법이 없다. 뭔말?

JUnit4에서 모든 문제를 해결 -&gt; 애너테이션이 등장

애너테이션 동작 방식을 보여주고자 직접 제작한 작은 테스트 프레임워크 사용할 것이다.

Test 애너테이션을 정의해보자.

```java
// 자동으로 수행되는 간단한 테스트용 애너테이션, 예외 발생되면 실패 처리.
import java.lang.annotation.*;
/**
 * 테스트 메서드임을 선언하는 애너테이션
 * 매개변수 없는 정적 메서드 전용
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Test {
}
```

메타 애너테이션 - 애너테이션의 애너테이션

```java
@Retention(RetentionPolicy.RUNTIME) // @Test가 런타임에도 유지되어야 한다
@Target(ElementType.METHOD) // @Test가 받드시 메서드 선언에서만 사용. 클래스나 필드 선언 x
```

> 스택오버플로우에 나오면 설명하기 - 주석: 매개변수 없는 정적 메서드 전용
>
> The comment before the Test annotation declaration says, “Use only on parameterless static methods.” It would be nice if the compiler could enforce this, but it can’t, unless you write an annotation processor to do so. For more on this topic, see the documentation for javax.annotation.processing.

이제 @Test 애너테이션을 적용해보자. 특징, marker 애너테이션 = 아무 매개변수 없이 단순히 대상에 마킹한다는 뜻 Test 이름에 오타나 메서드 선언 외의 프로그램 요소에 달면 컴파일러 오류를 내준다.

문제 - 여기서 성공, 실패, 잘못 사용한 경우를 뽑아내시오.

```java
// 마커 어노테이션
public class Sample {
    @Test
    public static void m1() { }        // 성공 1
    public static void m2() { } 
    @Test public static void m3() {    // 실패 2 
        throw new RuntimeException("Boom");
    }
    public static void m4() { }  
    @Test public void m5() { }   // 정적 메소드 x -> 잘못 사용한 경우 3
    public static void m6() { }
    @Test public static void m7() {    // 실패 2
        throw new RuntimeException("Crash");
    }
    public static void m8() { } // 이건 그냥 테스트가 아닌 것
}
```

현재 사용된 @Test는 Sample 클래스에 의미적으로 직접 영향을 주진 않고 애너태이션에 관심있는 프로그램에게 추가 정보를 제공할 뿐이다.

그 이유는 아래를 보자.

```java
public class RunTests {
    public static void main(String[] args) throws Exception {
        int tests = 0;
        int passed = 0;
        Class<?> testClass = Class.forName(args[0]);
        for (Method m : testClass.getDeclaredMethods()) { // Sample 안에 메서드들
            if (m.isAnnotationPresent(Test.class)) { // 실행할 메서드를 찾는다.
                tests++;
                try {
                    m.invoke(null);
                    passed++;
                } catch (InvocationTargetException wrappedExc) { // 예외 던질 경우
                    Throwable exc = wrappedExc.getCause();  // 원래 예외에 담긴 실패정보를 추출
                    System.out.println(m + " failed: " + exc);
                } catch (Exception exc) {
                    System.out.println("Invalid @Test: " + m);
                }
            }
        }
        System.out.printf("Passed: %d, Failed: %d%n",
                passed, tests - passed);
    }
}
```

* isAnnotationPresent -&gt; 실행할 메서드를 찾는다.
* 테스트 메서드 예외 던질 경우 -&gt; InvocationTargetException으로 감싸서 다시 던져준다.
* getCause - InvocationTargetException로 부터 원래 예외에 담긴 실패정보를 추출해 출력해준다.

![](../../.gitbook/assets/image%20%28150%29.png)

![](../../.gitbook/assets/image%20%28148%29.png)

![](../../.gitbook/assets/image%20%28147%29.png)

InvocationTargetException 이외 예외 -&gt; 인스턴스 메서드, 매개변수가 있는 메서드, 호출할 수 없는 메서드에 달았을 경우 생김. 위 Boom, Crash.

특정 예외를 던져야만 성공하는 테스트를 지원하도록 추가해보자.

```text
// Annotation type with a parameter
import java.lang.annotation.*;
/**
 * 명시한 예외를 던져야만 성공하는 테스트
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface ExceptionTest {
    Class<? extends Throwable> value(); // 추가 
}
```

Throwable을 확장한 클래스의 객체를 던지는 즉, 모든 예외\(와 오류\) 타입을 수용한다. \( = 한정적 타입토큰 \)

[ArithmeticException](https://docs.oracle.com/javase/7/docs/api/java/lang/ArithmeticException.html) devided by zero

```java
// 매개변수 하나짜리 애너테이션을 사용한 프로그램
// 예외를 던져야만 성공하는 테스트
public class Sample2 {
    @ExceptionTest(ArithmeticException.class)
    public static void m1() {  // 성공 
        int i = 0;
        i = i / i;
    }
    @ExceptionTest(ArithmeticException.class)
    public static void m2() {  // 실패 (wrong exception)
        int[] a = new int[0];
        int i = a[1];
    }
    @ExceptionTest(ArithmeticException.class)
    public static void m3() { }  // 실패 (no exception)
}
```

메인에 추가할 사항

```text
Class<? extends Throwable> excType =
    m.getAnnotation(ExceptionTest.class).value();
if (excType.isInstance(exc)) {
    passed++;
```

```java
public class RunTests {
    public static void main(String[] args) throws Exception {
        int tests = 0;
        int passed = 0;
        Class<?> testClass = Class.forName(args[0]);
        for (Method m : testClass.getDeclaredMethods()) {
            if (m.isAnnotationPresent(Test.class)) {
                tests++;
                try {
                    m.invoke(null);
                    passed++;
                } catch (InvocationTargetException wrappedExc) {
                    Throwable exc = wrappedExc.getCause();
                    System.out.println(m + " 실패: " + exc);
                } catch (Exception exc) {
                    System.out.println("잘못 사용한 @Test: " + m);
                }
            }
​
            if (m.isAnnotationPresent(ExceptionTest.class)) {
                tests++;
                try {
                    m.invoke(null);
                    System.out.printf("테스트 %s 실패: 예외 던지지 않음%n", m);
                } catch (InvocationTargetException wrappedEx) {
                    Throwable exc = wrappedEx.getCause();        
                    //중요 - 추가된 코드
                    //애너테이션 매개변수의 값을 추출하여 
                    //테스트 메서드가 올바른 예외를 던지는지 확인
                    Class<? extends Throwable> excType =
                        m.getAnnotation(ExceptionTest.class).value(); 
                    if (excType.isInstance(exc)) {
                        passed++;
                    } else {
                        System.out.printf(
                            "테스트 %s 실패: 기대한 예외 %s, 발생 예외 %s%n",
                            m, excType.getName(), exc);
                    }
                } catch (Exception exc) {
                    System.out.println("잘못 사용한 @ExceptionTest: " + m);
                }
            }
        }
​
        System.out.printf("성공: %d, 실패: %d%n",
                          passed, tests - passed);
    }
}
```

m1, m2, m3 결과를 보자

![](../../.gitbook/assets/image%20%28149%29.png)

> 해당 예외의 클래스 파일이 컴파일타임에는 존재했으나 런타임에 존재하지 않을 경우 TypeNotPresentException이 발생할 것이다.

복수개 예외 매개변수로 사용시. 애너테이션.

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface ExceptionTest {
    Class<? extends Exception>[] value(); // [] 배열 사용
}
--------------------------------------------------------------------------------
// 배열 파라미터 사용
public class Sample3 {   
    // ...
    @ExceptionTest({ IndexOutOfBoundsException.class,
                     NullPointerException.class })
    public static void doublyBad() {   // 성공
        List<String> list = new ArrayList<>();
​
        // 자바 API에 따르면
        // IndexOutOfBoundsException or NullPointerException 던질 수 있음
        list.addAll(5, null);
    }
}
--------------------------------------------------------------------------------   
public class RunTests {
    public static void main(String[] args) throws Exception {
        //...
        for (Method m : testClass.getDeclaredMethods()) {
            if (m.isAnnotationPresent(Test.class)) {
                //...
            }
            
            if (m.isAnnotationPresent(ExceptionTest.class)) {
                tests++;
                try {
                    m.invoke(null);
                    System.out.printf("Test %s failed: no exception%n", m);
                } catch (Throwable wrappedExc) {
                    Throwable exc = wrappedExc.getCause();
                    int oldPassed = passed;
                    Class<? extends Throwable>[] excTypes =
                            m.getAnnotation(ExceptionTest.class).value();
                    for (Class<? extends Throwable> excType : excTypes) {
                        if (excType.isInstance(exc)) {
                            passed++;
                            break;
                        }
                    }
                    if (passed == oldPassed)
                        System.out.printf("Test %s failed: %s %n", m, exc);
                }
            }
        }
        System.out.printf("Passed: %d, Failed: %d%n",
                passed, tests - passed);
    }
}
​
```

자바 8에선 여러개 값을 받는 애너테이션을 다른 방식으로도 만들 수 있다. 배열 매개변수 대신 @Repeatable 메타애너테이션 사용하면 된다.

주의할점은,

* @Repeatable 반환하는 컨테이너 애너테이션 하나더 정의 후 @Repeatable에 이 컨테이너 애너테이션의 클래스 객체를 매개변수로 전달한다.
* 내부 애너테이션 타입의 배열을 반환하는 value 메서드를 정의해야 한다.

```text
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Repeatable(ExceptionTestContainer.class) // 추가
public @interface ExceptionTest {
    Class<? extends Throwable> value();
}
------------------------------------------------
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface ExceptionTestContainer {
    ExceptionTest[] value();
}
------------------------------------------------
public class Sample4 {
    //...
    @ExceptionTest(IndexOutOfBoundsException.class)
    @ExceptionTest(NullPointerException.class)
    public static void doublyBad() {
        List<String> list = new ArrayList<>();      
        list.addAll(5, null);
    }
}
```

반복 가능 애너테이션을 여러번 단 다음 isAnnotationPresent로 반복 가능 애너테이션이 달렸는지 검사한다면 "그렇지 않다"라고 알려준다 \(컨테이너때문\). 그결과 애너테이션을 여러번 단 메서드들을 모두 무시하고 지나친다. 같은 이유 isAnnotationPresent로 컨테이너 애너테이션이 달렸는지 검사한다면 반복 가능 애너테이션을 한번만 단 메서드를 무시하고 지나간다. 그래서 달려있는 수와 상관없이 모두 검사하려면 둘을 따로따로 확인해야 한다.

따라서 반복 가능 애너테이션을 다루기 위한 코드는 다음과 같다

```java
public class RunTests {
    public static void main(String[] args) throws Exception {
        int tests = 0;
        int passed = 0;
        Class testClass = Class.forName(args[0]);
        for (Method m : testClass.getDeclaredMethods()) {
            if (m.isAnnotationPresent(Test.class)) {
                //...
            }
​
            // 따로따로 확인!
            if (m.isAnnotationPresent(ExceptionTest.class)
                    || m.isAnnotationPresent(ExceptionTestContainer.class)) {
                tests++;
                try {
                    m.invoke(null);
                    System.out.printf("테스트 %s 실패: no exception%n", m);
                } catch (Throwable wrappedExc) {
                    Throwable exc = wrappedExc.getCause();
                    int oldPassed = passed;
                    ExceptionTest[] excTests =
                            m.getAnnotationsByType(ExceptionTest.class);
                    for (ExceptionTest excTest : excTests) {
                        if (excTest.value().isInstance(exc)) {
                            passed++;
                            break;
                        }
                    }
                    if (passed == oldPassed)
                        System.out.printf("테스트 %s 실패: %s %n", m, exc);
                }
            }
        }
        System.out.printf("성공: %d, 실패: %d%n",
                          passed, tests - passed);
    }
}
```

마지막 페이지 글 다시 읽자ㅎㅎ

