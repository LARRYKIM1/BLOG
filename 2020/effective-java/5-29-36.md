# \[5주차\] 29-36

## 29 이왕이면 제네릭 타입으로 만들라 - 발

#### step 1

item 7의 Stack을 제너릭으로 만들어보자

#### step 2 - 제너릭으로 가는 첫단계

문제 - E와 같은 실체화 불가 타입으로 배열을 만들수 없다. 배열을 제너릭으로 만들려할때 일반적인 문제.

#### step 3 - 해결1: 제너릭 배열 생성을 금지하는 제약을 대놓고 우회하는 방법

Object 배열을 생성한 다음 제너릭 배열로 형변환. = 우회   
 unchecked cast가 나온다. 하지만 push 메서드를 통해 배열에 저장되는 원소의 타입은 항상 E이다. 다시말해, elements는 push\(E\)로 넘어온 E 인스턴스만 담는다. 따라서 이 비검사 형변환은 확실히 안전하다 -&gt; SuppressWarnings 사용   
 그런데 타입 안정성은 보장하지만 런타임 타입은 E\[\]가 아닌 Object\[\]다!

```java
Stack<String> stack = new Stack<>(); //타입 인수 String으로 적용
System.out.println(stack.getClass().getDeclaredField("elements").getType()); //Object가 나온다.
```

#### step 4 - 해결2: elements 필드의 타입을 E\[ \]에서 Object\[ \]로 바꾸는것

E는 실체화 불가 타입 -&gt; 컴파일러는 런타임에 이뤄지는 형변환이 안전한지 증명할 방법 x. 직접 증명하고 경고를 숨기자. Item 27에 따라 비검사 형변환 수행하는 할당문에서만 숨기자.

* step 3 장단점 
  * 장: 가독성 좋다. 코드도 짧다. 형변환 배열 생성시 한번. \(현업에서 선호\)
  * 단: 힙오염 발생. \(E가 Object가 아닌한\) 배열의 런타임 타입이 컴파일타임과 달르기 때문.
* step 4 장단점 
  * 장: 힙오염 안됨.
  * 단: 배열에서 원소를 읽을 때마다 형변환.

```java
//step 3 - 제너릭 배열 생성을 금지하는 제약을 대놓고 우회하는 방법
//step 4 - elements 필드의 타입을 E[ ]에서 Object[ ]로 바꾸는 것
public class Stack {
//public class Stack<E> { //step 2,3,4
    private Object[] elements; //step 4+
//    private E[] elements; //step 2
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    //@SuppressWarnings("unchecked") //step 3, 4-
    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY]; //step 4+
        //elements = new E[DEFAULT_INITIAL_CAPACITY]; //step 2 - 제너릭 배열 생성 x, 3-, 4-
        //elements = (E) new Object[DEFAULT_INITIAL_CAPACITY]; //step 3, 4-
    }
    public void push(Object e) {
    //public void push(E e) { //step 2, 3
        ensureCapacity();
        elements[size++] = e;
    }
    public Object pop() {
    //public E pop() { //step 2, 3, 4
        Object result = elements[--size];
        //E result = elements[--size];//step 2, 3
        //@SuppressWarnings("unchecked") E result = (E) elements[--size]; //step 4
        elements[size] = null;
        return result;
    }
    public boolean isEmpty() {
        return size == 0;
    }
    private void ensureCapacity() {
        if (elements.length == size)
            elements = Arrays.copyOf(elements, 2 * size + 1);
    }
}
```

## 30 이왕이면 제네릭 메서드로 만들라 - 발표

제네릭 메소드는 매개 타입과 리턴 타입으로 타입 파라미터를 갖는 메소드를 말합니다.   
 클래스와 마찬가지로, 메서드도 제네릭으로 만들 수 있다. 예, Collection 알고리즘 메서드\(binarySearch, sort\).

```java
// Create a list of strings 
        ArrayList<String> al = new ArrayList<String>(); 
        al.add("Geeks For Geeks"); 
        al.add("Friends"); 
        al.add("Dear"); 
        al.add("Is"); 
        al.add("Superb"); 

        Collections.sort(al, Collections.reverseOrder()); 

        System.out.println(al); 
//결과: [Superb, Is, Geeks For Geeks, Friends, Dear]
```

아래는 문제있는 메서드.

```java
// 합집합 반환
public class Union {
    public static Set union(Set s1, Set s2) {
        Set result = new HashSet(s1);
        result.addAll(s2);
        return result;
    }

    public static void main(String[] args) {
        Set s1 = Set.of("a", "b", "c");
        Set s2 = Set.of("d", "e", "f");
        Set unionSet = Union.union(s1,s2);
        System.out.println(unionSet);
    }
}

// 컴파일은 되지만 두개 경고 발생
Union.java:5: warning: [unchecked] unchecked call to
HashSet(Collection<? extends E>) as a member of raw type HashSet
    Set result = new HashSet(s1);
                ^
Union.java:6: warning: [unchecked] unchecked call to
addAll(Collection<? extends E>) as a member of raw type Set
    result.addAll(s2);
                ^
```

타입 안전하게 만들자.

```java
public class Union {
    // 제너릭 코드 - 타입 매개변수 목록은 static과 Set<E>사이, 메서드의 제한자-반환타입 사이
    // 세 집합의 타입이 모두 같아야한다.
    public static <E> Set<E> union(Set<E> s1, Set<E> s2) {
        Set<E> result = new HashSet<>(s1);
        result.addAll(s2);
        return result;
    }

    // 형변환하지 않아도 컴파일 잘된다.
    public static void main(String[] args) {
        Set<String> guys = Set.of("Tom", "Dick", "Harry");
        Set<String> stooges = Set.of("Larry", "Moe", "Curly");
        Set<String> aflCio = union(guys, stooges);
        System.out.println(aflCio);
    }
}
```

단순한 제너릭 메서라면 이정도면 충분. 유연성을 더 높이려면 와일드카드 타입\(item 31\)을 사용한다.

추가로 다른 예제 항등함수를 보자. Function.identity를 \(item 59\) 사용하면 되지만 직접 만들어보자.   
 궁금 - 함등함수는 어디서 사용될까...?   
 항등함수는 잘 사용되는 편은 아니며 스트림의 map\(\)으로 변환 작업할 때 변환 없이 그대로 처리할 때 사용된다.[출처](https://soft.plusblog.co.kr/88)

```java
UnaryOperator<String> uo = (x)->x.toUpperCase();
System.out.println(uo.apply("hello"));
```

```java
public class GenericSingletonFactory {
    // 제너릭 싱글톤 팩토리 패턴
    // 항등함수 객체는 상태가 없으니 요청할때 마다 새로 생성하는 것은 낭비.
    // 자바 제너릭이 실체화된다면 항등함수를 타입별로 하나씩 만들어야 했겠지만,
    // 소거 방식을 사용한 덕에 제너릭 싱글톤 하나면 충분하다.
    private static UnaryOperator<Object> IDENTITY_FN = (t) -> t;

    @SuppressWarnings("unchecked")
    public static <T> UnaryOperator<T> identityFunction() {
        // IDENTITY_FN을 UnaryOperator<T>로 형변환 하면  형변환 경고가 발생한다. 
        // 입력값을 수정없이 그대로 반환하는 함수이므로, 
        // T가 어떤 타입이든 UnaryOperator<T> 사용은 안전하다. 위 SuppressWarnings 추가
        return (UnaryOperator<T>) IDENTITY_FN; 
    }

    public static void main(String[] args) {
        String[] strings = { "jute", "hemp", "nylon" };
        UnaryOperator<String> sameString = identityFunction();
        for (String s : strings)
            System.out.println(sameString.apply(s)); // 형변환을 하지 않아도 오류 x, 경고 x

        Number[] numbers = { 1, 2.0, 3L };
        UnaryOperator<Number> sameNumber = identityFunction();
        for (Number n : numbers)
            System.out.println(sameNumber.apply(n));
    }
}
```

재귀적 타입 한정으로 타입 매개변수의 허용 범위를 한정할 수 있다. 주로 Comparable 과 함께 쓰인다.

최댓값 계산 RecursiveTypeBound 예.

```java
// 재귀적 타입 한정으로 사용해서 상호 비교가능성을 표현한다. 
public class RecursiveTypeBound {
    // 최댓값 리턴 - recursive type bound 사용
    public static <E extends Comparable<E>> E max(Collection<E> c) {
        if (c.isEmpty())
            throw new IllegalArgumentException("Empty collection");

        E result = null;
        for (E e : c)
            if (result == null || e.compareTo(result) > 0)
                result = Objects.requireNonNull(e);

        return result;
    }

    public static void main(String[] args) {
        List<String> sl = Arrays.asList("a","b","c");
        System.out.println(max(sl));
    }
}
```

> 이 메서드에 빈 컬렉션을 건내면 IllegalArgumentException을 던지니, Optional를 반환하도록 고치는 편이 나을 것이다. item 55

이번 아이템에서 설명한 관용구, 여기에 와일드카드를 사용한 변형\(item 31\), 그리고 시뮬레이트한 셀프타입 관용구\(item 2\)를 이해하고 나면 실전에서 마주치는 대부분의 재귀적 타입한정을 잘 다루게 될 것이다.

> 제네릭 타입과 마찬가지로, 클라이언트에서 입력 매개변수와 반환값을 명시적으로 형변환해야 하는 메서드보다 제네릭 메서드가 더 안전하며 사용하기도 쉽다. \(= 제네릭 메서드 사용하자\) 기존 클라이언트는 그대로 둔 채 새로운 사용자의 삶을 훨씬 편하게 만들어줄 것이다

