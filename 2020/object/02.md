---
description: '조영호 저 "오브젝트: 코드로 이해하는 객체지향 설계"를 읽고 정리한 내용입니다.'
---

# \#02 객체지향 프로그래밍

## 1 영화 예매 시스템 만들기 

온라인 영화 예매 시스템 시스템을 만들기 위해 알아야 되는 성격들을 알아보자.

### 1. "영화"와 "상영" 용어 구분 필요

* 영화: 영화가 가지고 있는 기본적인 정보
  * 예, **제목, 상영시간, 가격 정보** 등
* 상영: 관람하는 사건을 표현
  * 예, **상영 일자, 시간, 순번** 등

### 2. 할인액을 결정하는 두 가지 규칙

* 할인 조건\(discount condition\): **가격의 할인 여부를 결정**
  * 순서 조건: 상영 **순번을 이용해 할인** 여부를 결정하는 규칙 \(sequence condition\)
    * 예, 10번째 상영 영화를 예매한 사용자들에게 할인 혜택을 제공
  * 기간 조건: 상영 **시작 시간을 이용해 할인** 여부를 결정 \(period condition\)
    * 예,월요일 시작 시간이 오전 10시, 종료 시간이 오후 1시인 기간 조건을 사용하면, 
    * 매주 월요일 오전 10시부터 오후 1시 사이에 상영되는 모든 영화에 대해 할인 혜택 적용
* 할인 정책\(discount policy\): **할인 요금을 결정**
  * 금액 할인 정책: 예매 요금에서 **일정 금액을 할인**해주는 방식 \(amount discount policy\)
  * 비율 할인 정책: 정가에서 **일정 비율을 할인**해 주는 방식 \(percent discount policy\)

#### 추가적 풀이

* 영화별로 **하나의 할인 정책**만 할당 가능하며, 할인 정책을 **지정하지 않는 것도 가능**하다.
* 할인 조건은 **다수의 할인 조건을 함께 지정 가능**하며, **순서 조건과 기간 조건을 섞는 것도 가능**하다.

![&#xC870;&#xC601;&#xD638;, &#x300C;&#xC624;&#xBE0C;&#xC81D;&#xD2B8;&#x300D;, &#xC704;&#xD0A4;&#xBD81;&#xC2A4;, 2019](../../.gitbook/assets/image%20%2876%29.png)

아바타를 예매

![&#xC870;&#xC601;&#xD638;, &#x300C;&#xC624;&#xBE0C;&#xC81D;&#xD2B8;&#x300D;, &#xC704;&#xD0A4;&#xBD81;&#xC2A4;, 2019](../../.gitbook/assets/image%20%2874%29.png)



## 2 객체지향 프로그래밍을 향해

C++, **자바**, C\#과 같이 클래스 기반의 객체지향 언어에 익숙한 사람이라면, 가장 먼저 **어떤 클래스가 필요**한지 고민하고 **어떤 속성과 메서드가 필요**한지 고민한다. 안타깝게도 이것은 객체지향의 본질과는 거리가 멀다. 진정한 객체지향 패러다임으로의 전환은 **클래스가 아닌** **객체에 초점을 맞출 때**에만 얻을 수 있다.

* 어떤 **클래스**가 필요한지를 고민하기 전에 어떤 **객체**들이 필요한지 고민하라. \(클래스 != 객체\)
  * 클래스는 **공통적인 상태와 행동**을 공유하는 객체들을 추상화한 것이다. 
  * 따라서 클래스의 윤곽을 잡기 위해서는, 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야 한다.
* 객체를 ****협력하는 공동체의 일원보자.
  * 특성과 상태를 가진 객체들을 타입으로 분류하고 이 타입을 기반으로 클래스를 구현하라.

### 도메인의 구조를 따르는 프로그램

객체지향 패러다임이 강력한 이유는 요구사항을 분석하는 **초기 단계부터** 프로그램을 구현하는 **마지막 단계까지 객체라는 동일한 추상화 기법을 사용**할 수 있기 때문이다. 요구사항과 프로그램을 객체라는 동일한 관점에서 바라볼 수 있기 때문에, 도메인을 구성하는 개념들이 프로그램의 객체와 클래스로 매끄럽게 연결될 수 있다. \(도메인 - 사용자가 프로그램을 사용하는 분야\)

다음 타입들의 구조를 보고 관계를 유추해보자.

![](../../.gitbook/assets/image%20%2875%29.png)

클래스의 이름은 대응되는 도메인 개념의 이름과 동일하거나 적어도 유사하게 지어야 한다

![&#xB514;&#xB809;&#xD1A0;&#xB9AC; &#xAD6C;&#xC870;](../../.gitbook/assets/image%20%2878%29.png)

### Screening 

* 주목할 점
  * 인스턴스 변수의 가시성은 private이고, 메서드의 가시성은 public이라는 것이다. 
  * 다른 개발자에 의해 개발된 클래스를 사용할 때 가장 중요한 것은 **클래스의 경계**    를 구분 짓는 ****것이다.
  * 클래스는 내부와 외부로 구분되며, 훌륭한 클래스를 설계하기 위한 핵심은 어떤     부분을 외부에 공개하고 어떤 부분을 감출지를 결정하는 것이다.
  * 직접 접근할 수 없도록 막고, 적절한 Public 메서드를 통해서만 내부 상태를 변경 할 수 있게 하였다.

**자율적인 객체**

* 객체가 **상태**\(state\)와 **행동**\(behavior\)을 함  께 가지는 복합적인 존재이다.
* 객체지향 이전에 데이터와 기능이라는 독립적인 존재를 서로 엮어 프로그램을 구성했다. 
* 객체지향에서는 **데이터와 기능을 묶은 캡슐화를 사용**한다.
* **캡슐화와 접근 제어**는 객체를 **두 부분**으로 나눈다. **하나**는 **외부에서 접근 가능**한 부분으로 이를 **퍼블릭 인터페이스**\(public interface\)라고 부른다. **다른 하나**는 외부에서는 **접근 불가능**하고 오직 내부에서 만 접근 가능한 부분으로 이를 **구현**\(implementation\)이라고 부른다.
* 객체의 상태는 숨기고 행동만 외부에 공개해야 한다.

**프로그래머의 자유: 접근 제어 메커니즘으로 얻을 수 있는 효과**

* 역할 두가지 
  * 클래스 작성자 - 새로운 데이터 타입을 프로그램에 추가
  * 클라이언트 프로그래머 - 추가한 데이터 타입을 사용
* 구현  은닉 \(implementation hiding\) 
  * 클라이언트 프로그래머가 숨겨 놓은 부분에 마음대로 접근할 수 없도록 방지
  * 클라    이언트 프로그래머에 대한 영향을 걱정하지 않고도 내부 구현을 마음대로 변경
*  클래스를 개발할 때마다 **인터페이스와   구현**을 **깔끔하게 분리**하기 위해 노력해야 한다.
* 접근 제어 - 객체의 변  경을 관리할 수 있는 기법 중에서 가장 대표적인 것

### **Reservation**

Reservation의 reserve 메소드는 private 메서드\(calculateFee\)를 호출하였다.

![&#xC870;&#xC601;&#xD638;, &#x300C;&#xC624;&#xBE0C;&#xC81D;&#xD2B8;&#x300D;, &#xC704;&#xD0A4;&#xBD81;&#xC2A4;, 2019](../../.gitbook/assets/image%20%2877%29.png)

뒤에서 살펴보겠지만, **메시지와 메서드의 구분**에서부터 **다형성**\(polymorphism\)의 개념이 출발한다.



### Movie

예매 요금을 계산하기 위해서는 현재 영화에 적용돼 있는 할인 정책의 종류를 판단할 수 있어야 한다. 하지만 코드 어디에도 할인 정책을 판단하는 코드는 존재하지 않는다. 단지 discountPolicy에게 메시지를 전송할 뿐이다. 이것이 어색하다면, 객체지향 패러다임에 익숙하지 않은 것이다. 이코드 속에는 상속\(inheritance\)과  다형성 그리고 그 기반에는 추상화\(abstraction\)라는 원리가 숨겨져 있다. 

### Discountpolicy - AmountDiscountPolicy와 PercentDiscountPolicy \(부모-자식\)

이 두개를 부모클래스 Discountpolicy는 **인스턴스를 생성할 필요가 없기** 때문에 추상 클래스\(abstract\)로 구현했다.

할인 조건을 만족하는 Discountcondition이 하나라도 존재하는 경우에는 추상 메서드\(abstract method\)인 getDiscountAmount 메서드를 호출해 할인 요금을 계산한다.

Discountpolicy는 할인 여부와 요금 계산에 필요한 전체적인 흐름은 정의하지만 실제로 요금을 계산하는 부분은 추상 메서드인 getDiscountAmount 메서드에게 위임한다. 

부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴을 **TEMPLATE METHOD 패턴**이라고 부른다.

영화 가격 계산에 참여하는 모든 클래스 사이의 관계

![&#xC870;&#xC601;&#xD638;, &#x300C;&#xC624;&#xBE0C;&#xC81D;&#xD2B8;&#x300D;, &#xC704;&#xD0A4;&#xBD81;&#xC2A4;, 2019](../../.gitbook/assets/image%20%2879%29.png)

#### 상속과 다형성 

Movie가 DiscountPolicy를 인스턴스로 가졌지만, 그안에 있는 AmountDiscountPolicy와 PercentDiscountPolicy가 존재여부는 모른다.

확장 가능한 객체지향 설계가 가지는 특징은 **코드의 의존성과 실행 시점의 의존성**이 다르다. 이것이  다르면 다를 수록 코드가 어려워진다는 트레이드오프가 있다. 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워진다. 반면 유연성을 억제하면 코드를 이해하고 디버깅하기는 쉬워지지만 재사용성과 확장 가능성은 낮아진다.

Movie 클래스에서 DiscountPolicy 클래스로의 의존성이 어떻게 실행 시점에는 AmountDiscountPolicy나 PercentDiscountPolicy 인스턴스에 대한 의존성으로 바뀔 수 있을까? 

상속 개념을 짚어보자.

상속은 클래스를 하나 추가하고 싶은데 그 클래스가 기존의 어떤 클래스와 매우 흡사할 경우 재사용을 가능하게 해준다. 이로써 기존 클래스가 가지고 있는 모든 속성과 행동을 새로운 클래스에 포함시킬 수 있다. 또한, 부모 클래스의 구현은 공유하면서도 행동이 다른 자식 클래스를 쉽게 추가할 수 있다.  \(행동이 다르다=오버라이딩해 수정할 경우\). 용어적으로, 차이에 의한 프로그래밍 \(programming by difference\)이라 한다.

C++의 창시자인 비야네 스트롭스트룹\(Bjarne Stroustrup\)은 **슈퍼클래스와 서브 클래스**라는 용어가 **뜻이 모호**하고 오해의 소지가 있다고 보고 C++에는 **기반 클래스**\(base class\)와 **파생 클래스**\(derived class\)라는 새로운 용어를 도입하였다.





