---
description: 김영한 저 "자바 ORM 표준 JPA 프로그래밍"을 읽고 정리한 내용입니다.
---

# \#15 고급주제와 성능최적화

## 주제

* 예외 처리 
* 엔티티 비교 주의점과 해결 방법 
* 프록시 심화 주제 
* 성능 최적화
  * N+1 문제
  * 읽기 전용 쿼리의 성능: 최적화 엔티티를 단순히 조회만 하면 영속성 컨텍스트에 스냅샷을 유지할 필요도 없고 영속성 컨텍스트를 플러시할 필요도 없다. 엔티티를 읽기 전용으로 쿼리할 때 성능 최적화 방안을 다룬다.
  * 배치 처리
  * SQL 쿼리 힌트 사용: 하이버네이트를 주로 다룬다.
  * 트랜잭션을 지원하는 쓰기 지연과 성능 최적화: 트랜잭션을 지원하는 쓰기 지연을 통해 성능을 최적화하는 방법을 다룬다. 

## 1. 예외 처리 

### 1.1 JPA 표준예외 정리 

* **`JPA 모든 예외`** &lt; **`PersistenceException`** &lt; **`RuntimeException`**  즉, JPA 예외는 모두 **언체크** 예외이다. [링크](https://close852.tistory.com/47)
* JPA 표준 예외는 크게 2가지로 나눌 수 있다.
  * 트랜잭션 롤백을 표시하는 예외
  * 트랜잭션 롤백을 표시하지 않는 예외

![&#xCD9C;&#xCC98;: https://www.objectdb.com/api/java/jpa/exceptions](../../.gitbook/assets/image%20%2847%29.png)

#### 트랜잭션 롤백을 표시하는 예외\(빨간색\)

* 심각한 예외이므로 복구해선 안 된다. 강제로 커밋해도 트랜잭션이 커밋되지 않고 대신에   RollbackException 예외가 발생한다.

![](../../.gitbook/assets/image%20%2849%29.png)

#### 트랜잭션 롤백을 표시하지 않는 예외

* 심각한 예외가 아니다. 개발자가 판단해서 트랜잭션 커밋, 롤백한다.

![](../../.gitbook/assets/image%20%2851%29.png)

### 1.2 스프링 프레임워크의 JPA 예외 변환

 서비스 계층에서 JPA의 예외를 직접 사용하면 JPA에 의존하게 된다. 아래는 추상화된 예외들이다.

![&#xCD9C;&#xCC98;: &#xAE40;&#xC601;&#xD55C; &#xC800; &quot;&#xC790;&#xBC14; ORM &#xD45C;&#xC900; JPA &#xD504;&#xB85C;&#xADF8;&#xB798;&#xBC0D;&quot;](../../.gitbook/assets/image%20%2841%29.png)

* JPA 표준 명세상 발생할 수 있는 다음 두 예외도 추상화 해서 제공한다.

![&#xCD9C;&#xCC98;: &#xAE40;&#xC601;&#xD55C; &#xC800; &quot;&#xC790;&#xBC14; ORM &#xD45C;&#xC900; JPA &#xD504;&#xB85C;&#xADF8;&#xB798;&#xBC0D;&quot;](../../.gitbook/assets/image%20%2846%29.png)

### 1.3 스프링 프레임워크에 JPA 예외 변환기 적용

* JPA 예외를 스프링 프레임워크가 제공하는 추상화된 예외로 변경하려면 **`PersistenceExceptionTranslationPostProcessor`**를 스프링 빈으로 등록한다.

```java
//JavaConfig 설정 
@Bean
public PersistenceExceptionTranslationPostProcessor
exceptionTranslation() {
    return new PersistenceExceptionTranslationPostProcessor();
}
```

* **`@Repository`**를 사용한 곳에  예외변환 AOP를 적용해서, JPA 예외를 스프링 프레임워크가 추상화한 예외로 변환해준다. 아래 findMember\(\) 메소드가  조회된 데이터가 없을 경우.

```java
@Repository
public class NoResultExceptionTestRepository {
    
    @Persistencecontext EntityManager em;
    
    //리턴값이 없다고 가정 
    //javax.persistence.NoResultException 발생 
    //메소드 빠져나갈때 AOP 인터셉터 동작
    //org.springframework.dao.EmptyResultDataAccessException로 예외 변환 후 반환 
    public Member findMember() { 
        return em.createQuery("select m from Member m", Member.class)
        .getSingleResult();
    }
}

//추상화된 예외를 변환하지 않을 경우 
@Repository
public class NoResultExceptionTestService {
    @Persistencecontext EntityManager em;
    piiblic member findMember() throws javax.persistence.NoResultException
    {
        return em.createQuery("select m from Member m",
        Member.class).getSingleResult();
    }
}
```

## 1.4 롤백 시 주의사항

* 데이터베이스의 반영사항만 롤백하였을 경우 영속성 컨택스트 내부 객체는 그대로 남아다. 따라서 트랜잭션  이 롤백된 영속성 컨텍스트를 그대로 사용하는 것은 위험하다.

1. **트랜잭션당 영속성 컨택스트 전략**  - 문제생겼을 때 트랜잭션 AOP 종료시점 트랜잭션 롤백하면서 영속성 컨택스트 함께 종료하므로 문제가 없다. 
2. **OSIV 사용 전략\(문제됨\)**  - 영속성 컨택스트 범위 &gt; 트랜잭션 범위일 경우 문제가 발생한다. 이유 - 롤백하고 남아있는 영속성 컨택스트에 이상이 발생해도 다른 컨택스트에서 그대로 사용할 수 있다. 해결방법 - EntityManger.clear\(\) 영속성 컨택스트 초기화 해주기.  doRollback 메소드를 참고하자?

## 2. 엔티티 비교

equals 3가지 비교방법 직접 해보기..

1. assertTrue\(member1 == member2\);
2. assertTrue\(member1.equals\(member2\)\) //이렇게?
3. member.getld\(\).equals \(findMember.getld\(\)\) //데이터베이스 식별자 비교

* 비교 방법 3가지 
  * 동일성\(identical\): == 비교가 같다. 
  * 동등성\(equivalent\): equals\(\) 비교가 같다. 
  * 데이터베이스 동등성: @Id인 데이터베이스 식별자가 같다.
* 1차 캐시 - 애플리케이션 수준의 반복 가능한 읽기
  * 같은 영속성 컨텍스트에서 엔티티 조회시 항상 같은 인스턴스를 반환한다.

```java
Member member1 = em.find(Member.class, "IL");
Member member2 = em.find(Member.class, "1L");
assertTrue(member1 == member2); //둘은 같은 인스턴스다.
```

### 2.1 PC가 같을 때, 엔티티 비교

* 위 3가지 모두 동일로 나온다.

![&#xCD9C;&#xCC98;: &#xAE40;&#xC601;&#xD55C; &#xC800; &quot;&#xC790;&#xBC14; ORM &#xD45C;&#xC900; JPA &#xD504;&#xB85C;&#xADF8;&#xB798;&#xBC0D;&quot;](../../.gitbook/assets/image%20%2843%29.png)

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = "classpath: appConfig.xml")
@Transactional //트랜잭션 안에서 테스트를 실행한다.
public class MemberServiceTest {
    @Autowired MemberService memberservice;
    @Autowired MemberRepository memberRepository;
    @Test
    
    public void 회원가입 () throws Exception {
    
        //Given
        Member member = new Member("kim");
        
        //When
        Long saveld = memberService.join(member);
        
        //Then
        Member findMember = memberRepository.fineOne (saveld)
        assertTrue(member == findMember); //참조값 비교   
    }
}

@Transactional
public class MemberService {
    @Autowired MemberRepository memberRepository;
    
    public Long join(Member member) {
        memberRepository.save(member);
        return member.getld();
    }
}

@Repository
public class MemberRepository {
    @Persistencecontext
    EntityManager em;
    
    public void save(Member member) {
        em.persist(member);
    }
    
    public Member findOne (Long id) {
        return em.find(Member. class, id);
    }
}
```

### 2.2 PC가 다를 때, 엔티티 비교

*  identical\(==\)에서 다르다고 나온다.
* 실습 - 테스트 클래스 **`@Transactional`** 을 없애준다.

![ORM](../../.gitbook/assets/image%20%2844%29.png)

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = "classpath: appConfig.xml")
//@Transactional 
public class MemberServiceTest {
    @Autowired MemberService memberservice;
    @Autowired MemberRepository memberRepository;
    @Test
    
    public void 회원가입 () throws Exception {
    
        //Given
        Member member = new Member("kim");
        
        //When
        Long saveld = memberService.join(member);
        
        //Then
        Member findMember = memberRepository.fineOne (saveld)
        assertTrue(member == findMember); //참조값 비교   
    }
}

@Transactional
public class MemberService {
    @Autowired MemberRepository memberRepository;
    
    public Long join(Member member) {
        //...
        memberRepository.save(member);
        return member.getld();
    }
}

@Repository
public class MemberRepository {
    @Persistencecontext
    EntityManager em;
    
    public void save(Member member) {
        em.persist(member);
    }
    
    public Member findOne (Long id) {
        return em.find(Member. class, id);
    }
}
```

지금처럼 영속성 컨텍스트가 달라지면 동일성 비교는 실패한다. 이때는 **데이터베이스 동등성 비교**를 사용해야 한다. 하지만 엔티티를 영속화해야 식별자를 얻어 비교할 수 있다는 문제가 있기에,  이때는 동등성 비교\(equals\(\)\)를 사용할 수 있다. 

## 3. 프록시 심화 주제

프록시를 사용하는 방식의 예상하지 못한 문제들에 대해 알아보자.

### 3.1 영속성 컨택스트와 프록시



### 3.2  상속관계와 프록시 

상속관계\(OrderItem&lt;-&gt;Item-Album, Movie, Book\)를 프록시로 조회할 때 발생할 수 있는 문제점

프록시를 부모 타입으로 조회하면 문제가 발생한













