---
description: 'Raoul-Gabriel Urma 저 「Modern Java in Action, 2019」를 읽고 정리하였습니다.'
---

# \# 1장 자바 8, 9, 10 그리고 11에는 무슨일이 일어나고 있는가?

## 1.1 주목할 만한 이야기

자바 8에서는 어느 버전보다 많은 변화가 있었고, 자바 9에서 주목할 만한 생산성에 변화를 더하고, 자바10에서는 type inference에 대해 손봐서 내놓았다.

```java
//자바 8 전
Collections.sort(inventory, new Comparator<Apple>() {
    public int compare(Apple a1, Apple a2){
        return a1.getWeight().compareTo(a2.getWeight());
    }
});

//자바 8
// 다른 메서드에 메서드를 넘기는 것이 가능해짐. comparing 메서드.
inventory.sort(comparing(Apple::getWeight)
```

멀티코어로 바껴가는 하드웨어도 자바에 영향을 미쳤다. 

자바 8 이전에는, 코어들을 사용하기위해 쓰레드를 잘 활용하라고 하는데, 실상 쓰레드를 다루는 일은 error-prone하고 어렵다. 자바 1.0에서도 쓰레드와 락이 있었고, 심지어 메모리 모델도 있었다. 그러나 비전문가들이 이 기능들을 사용하는데는 앞서말한 문제들이 있었다.

자바 5에서는 산업적으로 사용할 목적으로 쓰레드풀이나 동시적인 컬렉션들과 같은 블록들을 추가했었고, 자바 7에서는 fork/join 프레임워크와 병렬성을 좀더 실용적으로 만들었다. 하지만 여기까지도 사용하기 어려웠다. 자바 8에서 부터 실질적으로 사용하기 쉬운 병렬성이 나왔다.

* 자바 8의 중요한 추가 
  * The Streams API 
  * Techniques for passing code to methods
  * Default methods in interface

## 1.2 왜 자바는 아직도 변하고 있는가?

수백개의 프로그래밍 언어가 있고 살아남기 위해서는 진화가 필요하다. C나 C++의 경우는 오래됐고 프로그래밍 안정성이 부족하지만 runtime footprint가 작다는 강점이 있어 OS를 개발하거나 임베디드 시스템에서 아직도 많이 사용되고 있다. 그리고 Algol, COBOL, Pascal 같은 진화 하지 못한 언어들은 죽었다. 자바가 익숙하지 않았던 테라바이트 단위의 빅데이터를 처리하기 위해 새로운 개념 도입도 필요하게 되었다.

### 1.2.1 프로그래밍 언어의 생태계에서 자바 위치

참고, 오늘날 서브시스템을 담는 큰시스템 디자인이 주로 사용되는데, **디폴트 메소드와 모듈들을 도입**해서 해결하였다.

### 1.2.2 스트리밍 프로세싱  

스트림은 한 번에 하나씩 생성되는 일련의 데이터 항목이다.

유닉스를 예로 들어보자. 

```java
//파일 두개를 합쳐 모든 문자를 소문자로 바꾸고 정렬후 뒤 3줄을 가져온다.
cat file1 file2 | tr "[A-Z]" "[a-z]" | sort | tail -3
```





### 1.2.3 behavior parameterization을 이용해 메서드에 코드 보내기

참고, 오늘날 서브시스템을 담는 큰시스템 디자인이 주로 사용되는데, 디폴트메소드와 모듈들을 도입해서 해결하였다.

### 1.2.4 병렬성\(Parallelism\)과 공유된 변경가능 데이터



```java
 
```

### 1.2.5 자바 진화의 필요성

## 1.3 자바에서의 함수

### 1.3.1 1급 객체\(first-class citizen\)로서의 메서드와 람다 



```java
 
```

### 1.3.2 코드 전달 예제

### 1.3.3 메서드 전달부터 람다까지

## 1.4 스트림

### 1.4.1 멀티쓰레딩의 어려움

## 1.5 디폴트 메서드와\(Default methods\) 자바 모듈 

## 1.6 함수형 프로그래밍으로 부터온 좋은 생각들



```java
 
```

## 정리

 

